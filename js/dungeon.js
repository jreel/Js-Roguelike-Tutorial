/**
 * Created by jreel on 4/19/2015.
 *
 * Based on the "Building a Roguelike in Javascript" tutorial by Dominic
 * http://www.codingcookies.com/2013/04/01/building-a-roguelike-in-javascript-part-1/
 *
 * Using the rot.js library developed by Ondrej Zara
 * http://ondras.github.io/rot.js/hp/
 */

Game.Dungeon = {};

/*
Basic BSP Dungeon generation
from http://www.roguebasin.com/index.php?title=Basic_BSP_Dungeon_generation

1.  start with rectangular dungeon filled with wall cells

2.  split recursively until each sub-dungeon has approximately the size of a room.
    a.  choose a random direction (hSplit or vSplit)

    b.  choose a random position (x or y)
        make sure split position is not too close to dungeon border, so a min-sized room can fit.
        different rules on splitting position can result in more homogeneous (position 0.45 - 0.55)
        or heterogeneous (0.1 - 0.9) sub-dungeons.

    c.  split into two sub-dungeons.
        one rect goes in, and if successful, two rects come out

 3.  repeat until the lowest sub-dungeons have approximately the size of partitions wanted,
     or until possibly other conditions are met (such as max iterations for instance)
 */

Game.Dungeon.BSP = function(width, height, tileset, options) {
    options = options || {};

    if (!tileset) {
        tileset = Game.Tilesets.cave;
    }
    this.tileset = tileset;

    this.minRoomSize = options['minRoomSize'] || 3;
    this.minRoomWidth = options['minRoomWidth'] || this.minRoomSize;
    this.minRoomHeight = options['minRoomHeight'] || this.minRoomSize;
    this.maxRoomSize = options['maxRoomSize'] || 10;
    this.maxRoomWidth = options['maxRoomWidth'] || this.maxRoomSize;
    this.maxRoomHeight = options['maxRoomHeight'] || this.maxRoomSize;
    this.maxIterations = options['maxIterations'] || 5;

    this.largerRoomChance = options['largerRoomChance'] || 0.6;
    /*  splitConstraint = (option; +/- 0.5, to constrain splitPos)
     (example; if option = 0.05, splitPos would be limited to 0.45 - 0.55 of avail width/height)
     (if not passed in, we can choose random value from 0 - 0.5: Math.random() * 0.5);
    */
    this.splitConstraint = options['splitConstraint']  || Math.random() * 0.5;

    /* partitions array to store the final available areas generated by the trySplit method */
    this.partitions = [];

    /* 'master' roomRect to start with */
    this.masterRoom = new Game.Geometry.roomRect(0, 0, width - 1, height - 1);
    this.masterWidth = width;
    this.masterHeight = height;

    this.rooms = [];
    this.corridors = [];
};

Game.Dungeon.BSP.prototype.generate = function() {
    // make the partitions
    this.trySplit(this.masterRoom, 0);      // populates this.partitions[]

    // make the rooms within partitions
    this.createRooms(this.largerRoomChance);    // populates this.rooms[]

    // make a 'graph' from the rooms
    var adjacencyList = this.makeRoomsGraph(this.rooms);        // creates & populates this.roomsGraph[]
    // roomsGraph is an array of connections: {start:{room, x,y}, end:{room, x,y}, dir, distance}
    // also returns adjacencyList: a hashtable of roomIndex: neighborsList[]

    // use the graph with some BFS logic to figure out corridor placements
    this.placeCorridors(adjacencyList, randomInt(0, this.rooms.length - 1));
    // this populates an internal roomConnections table
    // it calls this.makeCorridor, which populates this.corridors
};

Game.Dungeon.BSP.prototype.trySplit = function(parentRect, currentIteration) {
    // in case we do something dumb and forget to pass in '0' on the first call
    if (currentIteration === null || currentIteration === undefined) {
        currentIteration = 0;
    }

    var cantSplit = false;      // to be changed to true if any "break" condition is met

    // cache parentWidth, parentHeight
    var parentWidth = parentRect.getWidth();
    var parentHeight = parentRect.getHeight();

    // if the room we are trying to split is small enough (within the max size limits)
    // and if we've already done enough splits, break
    if (parentWidth < this.maxRoomWidth && parentHeight < this.maxRoomHeight &&
        currentIteration >= this.maxIterations) {
        cantSplit = true;

    // if the room we are trying to split is smaller in both directions than min size, break
    } else if (parentWidth <= this.minRoomWidth && parentHeight <= this.minRoomHeight) {
        cantSplit = true;
    }

    if (cantSplit) {
        // parent is a leaf node, add to the partitions array
        this.partitions.push(parentRect);

    } else {
        // choose a random axis to try to split along
        // var splitAxis = randomInt(0, 1);    // horizontal = 1, vertical = 0.

        // instead of completely random, we should compare the parent width to the parent height,
        // and favor one axis over the other.
        var whDiff = parentWidth - parentHeight;        // if (+), width is greater; if (-), height is greater
        // simple solution:
        // var splitAxis = (whDiff > 0) ? 0 : 1;        // where 0 = vertical, 1 = horizontal.
        // however, that would always favor a vertical split in cases where width == height.
        //
        // we could try:
        // var splitAxis = (whDiff > 0) ? 0 : ( (whDiff < 0) ? 1 : randomInt(0, 1) );
        //
        // however, the above solution will always favor the 'ideal' split axis,
        // which will result in very 'homogeneous' dungeons.
        // We could take the 'homogeneity/heterogeneity' factor into account using the splitConstraint
        // (which is what it's designed to do).
        //
        // We could find the splitAxis as above, and then have a chance to 'flip' it, based on splitConstraint.
        // Since splitConstraint is typically from 0.05 (more homogeneous) to 0.45 (more heterogeneous),
        // that seems like the perfect parameter for what we are trying to do here. :)

        var splitAxis = (whDiff > 0) ? 0 : ( (whDiff < 0) ? 1 : randomInt(0, 1) );
        if (ROT.RNG.getUniform() < this.splitConstraint) {
            splitAxis = !splitAxis;
        }

        var checkAltAxis = false;           // we can check the other axis if the original one fails

        var xMin, yMin, xMax, yMax;
        var minSplitPos, maxSplitPos;
        var constraintMin, constraintMax;
        // we want to run this at most twice: once for each axis.
        // if we can't make a good split on the first run, we set checkAltAxis to true;
        // if we can't make a good split on the second run, we also set cantSplit to true.
        while (! (checkAltAxis && cantSplit)) {
            // see if this is a repeat check on the other axis
            if (checkAltAxis) {
                splitAxis = !splitAxis;
            }

            // choose a random split position (x or y)
            // make sure split position isn't too close to parent border, so a min-sized room can still fit
            xMin = parentRect.topLeftX;
            yMin = parentRect.topLeftY;
            xMax = parentRect.bottomRightX;
            yMax = parentRect.bottomRightY;

            // these are originally defined only based on the available geometry
            minSplitPos = splitAxis ? (yMin + this.minRoomHeight) : (xMin + this.minRoomWidth);
            maxSplitPos = splitAxis ? (yMax - this.minRoomHeight) : (xMax - this.minRoomWidth);

            // now we want to compare these to splitConstraint and choose the tightest range
            // splitConstraint is applied as follows:
            // constraintMin (horizontal):    (0.5 - splitConstraint) * parentHeight
            // constraintMin (vertical):      (0.5 - splitConstraint) * parentWidth
            // constraintMax (horizontal):    (0.5 + splitConstraint) * parentHeight
            // constraintMax (vertical):      (0.5 + splitConstraint) * parentWidth
            constraintMin = Math.floor((0.5 - this.splitConstraint) * (splitAxis ? parentHeight : parentWidth));
            constraintMax = Math.ceil((0.5 + this.splitConstraint) * (splitAxis ? parentHeight : parentWidth));

            // if the constraint (min, max) is a tighter range than the geometry-based (min, max) then use that
            if (constraintMin > minSplitPos && constraintMax < maxSplitPos) {
                minSplitPos = constraintMin;
                maxSplitPos = constraintMax;
            }

            // if minSplitPos or maxSplitPos is out of bounds, see if checkAltAxis is also true
            // if so, then we've run both axes already, so set cantSplit true, and break.
            if (minSplitPos >= (splitAxis ? yMax : xMax) ||
                maxSplitPos <= (splitAxis ? yMin : xMin) ||
                minSplitPos > maxSplitPos) {
                if (!checkAltAxis) {
                    checkAltAxis = true;
                } else {
                    cantSplit = true;
                }
            } else {
                break;
            }
        }

        if (cantSplit) {               // no reason to run the rest of it if we already know we can't split
            // parent is a leaf node, add to the partitions array
            this.partitions.push(parentRect);

        } else {

            var splitPos = randomInt(minSplitPos, maxSplitPos);
            // note that neither childRect will include the row/col (depending on splitAxis) of the splitPos
            // in other words, childRect will be a virtual "room" carved out of a solid dungeon,
            // subject to further splitting

            // var childATopLeftX = xMin;
            // var childATopLeftY = yMin;
            var childABottomRightX = splitAxis ? xMax : (splitPos - 1);
            var childABottomRightY = splitAxis ? (splitPos - 1) : yMax;

            var childRectA = new Game.Geometry.roomRect(xMin, yMin, childABottomRightX, childABottomRightY);

            var childBTopLeftX = splitAxis ? xMin : (splitPos + 1);
            var childBTopLeftY = splitAxis ? (splitPos + 1) : yMin;
            // var childBBottomRightX = xMax;
            // var childBBottomRightY = yMax;

            var childRectB = new Game.Geometry.roomRect(childBTopLeftX, childBTopLeftY, xMax, yMax);

            this.trySplit(childRectA, currentIteration + 1);
            this.trySplit(childRectB, currentIteration + 1);

        }
    }
};

/*
4.  create room with random size in each leaf of the tree (each sub-dungeon).
    room must be contained within the corresponding sub-dungeon.
    the BSP tree algorithm prevents overlapping partitions.
*/
Game.Dungeon.BSP.prototype.createRooms = function(largerRoomChance) {
    if (this.partitions === []) {
        return;
    }

    if (this.rooms === null || this.rooms === undefined) {
        this.rooms = [];
    }

    largerRoomChance = largerRoomChance || 0.5;

    // loop through the partitions array
    for (var p = 0; p < this.partitions.length; p++) {
        var partition = this.partitions[p];
        // for each partition, pick a random (x,y) for room (topLeftX, topLeftY)
        // making sure that minRoomSize can still fit

        // set the boundaries first
        var minRoomTopLeftX = partition.topLeftX;
        var maxRoomTopLeftX = partition.topLeftX + (partition.getWidth() - this.minRoomWidth);

        var minRoomTopLeftY = partition.topLeftY;
        var maxRoomTopLeftY = partition.topLeftY + (partition.getHeight() - this.minRoomHeight);

        // now pick a top left from the established boundaries
        // start with the min value, and roll vs largerRoomChance
        // if roll > largerRoomChance, test min + 1
        // and so on, until we hit the max value
        // this should favor larger room sizes better than a simple random(min, max).

        // var roomTopLeftX = randomInt(minRoomTopLeftX, maxRoomTopLeftX);
        // var roomTopLeftY = randomInt(minRoomTopLeftY, maxRoomTopLeftY);

        var roomTopLeftX;
        for (var x = minRoomTopLeftX; x <= maxRoomTopLeftX; x++) {
            var roll = ROT.RNG.getUniform();
            if (roll < largerRoomChance) {
                roomTopLeftX = x;
                break;
            } else {
                // make an exception if we're already at the end with no break yet
                if (x == maxRoomTopLeftX) {
                    roomTopLeftX = x;
                    break;
                }
            }
        }

        var roomTopLeftY;
        for (var y = minRoomTopLeftY; y <= maxRoomTopLeftY; y++) {
            var roll = ROT.RNG.getUniform();
            if (roll < largerRoomChance) {
                roomTopLeftY = y;
                break;
            } else {
                // make an exception if we're already at the end with no break yet
                if (y == maxRoomTopLeftY) {
                    roomTopLeftY = y;
                    break;
                }
            }
        }

        // after getting a random (topLeftX, topLeftY) for our room (from the above limits)
        // get a random room size, i.e., a random (x,y) for room (bottomRightX, bottomRightY)

        var maxRoomBottomRightX = partition.bottomRightX;
        var minRoomBottomRightX = roomTopLeftX + (this.minRoomWidth - 1);

        var maxRoomBottomRightY = partition.bottomRightY;
        var minRoomBottomRightY = roomTopLeftY + (this.minRoomHeight - 1);

        // same as before, pick a bottom right from the established boundaries
        // start with the max (to favor larger rooms) and roll
        // if roll fails, test max - 1, and so on, until we hit min

        // var roomBottomRightX = randomInt(minRoomBottomRightX, maxRoomBottomRightX);
        // var roomBottomRightY = randomInt(minRoomBottomRightY, maxRoomBottomRightY);

        var roomBottomRightX;
        for (var x = maxRoomBottomRightX; x >= minRoomBottomRightX; x--) {
            var roll = ROT.RNG.getUniform();
            if (roll < largerRoomChance) {
                roomBottomRightX = x;
                break;
            } else {
                // make an exception if we're already at the end with no break yet
                if (x == minRoomBottomRightX) {
                    roomBottomRightX = x;
                    break;
                }
            }
        }

        var roomBottomRightY;
        for (var y = maxRoomBottomRightY; y >= minRoomBottomRightY; y--) {
            var roll = ROT.RNG.getUniform();
            if (roll < largerRoomChance) {
                roomBottomRightY = y;
                break;
            } else {
                // make an exception if we're already at the end with no break yet
                if (y == minRoomBottomRightY) {
                    roomBottomRightY = y;
                    break;
                }
            }
        }

        var room = new Game.Geometry.roomRect(roomTopLeftX, roomTopLeftY, roomBottomRightX, roomBottomRightY);
        this.rooms.push(room);
    }
};

Game.Dungeon.BSP.prototype.createGridArray = function(arrayToUse) {
    // parameter determines which array to use, this.rooms or this.partitions
    if (!arrayToUse || arrayToUse == []) { return []; }
    if (!(arrayToUse == this.rooms || arrayToUse == this.partitions)) { return []; }

    // generate a new dungeon grid using masterWidth and masterHeight
    // filling all tiles with wallTile
    var grid = new Array(this.masterWidth);
    for (var x = 0; x < this.masterWidth; x++) {
        grid[x] = new Array(this.masterHeight);
        for (var y = 0; y < this.masterHeight; y++) {
            grid[x][y] = this.tileset.wall;
        }
    }

    // loop through the chosen array.
    for (var p = 0; p < arrayToUse.length; p++) {
        // for each room/partition in chosen array, loop through the tiles
        for (var pX = arrayToUse[p].topLeftX; pX <= arrayToUse[p].bottomRightX; pX++) {
            for (var pY = arrayToUse[p].topLeftY; pY <= arrayToUse[p].bottomRightY; pY++) {
                grid[pX][pY] = this.tileset.floor;
            }
        }
    }

    // if it was the rooms array, and if we already have a corridors array,
    // apply that as well.
    if (arrayToUse == this.rooms && this.corridors && this.corridors !== []) {
        // loop through corridors array
        for (var c = 0; c < this.corridors.length; c++) {
            var corr = this.corridors[c];
            grid[corr.x][corr.y] = this.tileset.corridor;
        }
    }

    return grid;
};

Game.Dungeon.BSP.prototype.consoleOut = function(grid) {
    if (!grid) {
        return;
    }

    // convert array to string for output.
    // (notice we need to break by rows, so the loops are reversed from the usual)
    var gridOut = "\n\r";
    for (var y = 0; y < grid[0].length; y++) {
        for (var x = 0; x < grid.length; x++) {
            if (grid[x][y] === Game.Tile.nullTile) {
                gridOut += "█";
            } else if (grid[x][y] === this.tileset.floor) {
                //gridOut += "░";
                var roomNumber = this.isWithinRoom(x, y);
                if (roomNumber > -1) {
                    gridOut += '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.charAt(roomNumber);
                } else {
                    gridOut += this.tileset.floor.character;
                }

            } else if (grid[x][y] === this.tileset.wall) {
                gridOut += this.tileset.wall.character;
            } else if (grid[x][y] === this.tileset.corridor) {
                gridOut += this.tileset.corridor.character;
            }
        }
        gridOut += "\n\r";
    }

    console.log(gridOut);
};

Game.Dungeon.BSP.prototype.makeRoomsGraph = function(rooms) {
    rooms = rooms || this.rooms;

    var roomsGraph = [];   // array of connections: {start:{room, x,y}, end:{room, x,y}, dir, distance}
    var adjacencyList = {}; // hashtable of roomIndex: [neighborsList]
    // loop through directions (0 = N, 1 = E, 2 = S, 3 = W)
    for (var dir = 0; dir < 4; dir++) {
        // loop through rooms array
        for (var r = 0; r < rooms.length; r++) {

            var wall = this.getPerimeters(rooms[r], dir);   // array of {x, y, dir}
            // loop through each element in [wall].
            // scan in dir until another room is found
            // or until map edge is reached.

            for (var w = 0; w < wall.length; w++) {
                var startX = wall[w].x;
                var startY = wall[w].y;

                var current = wall[w];
                var next = current;
                var endRoomFound = false;
                var distance = 1;
                do {
                    next = this.getNextCorridorTile(current);   // returns next if within map bounds
                    if (next != current) {      // we can continue in this dir.

                        // check if we've hit a room yet
                        var foundRoomIndex = this.isWithinRoom(next.x, next.y);

                        if (foundRoomIndex > -1) {  // we found a room!
                            endRoomFound = true;
                            roomsGraph.push({
                                            start: {
                                                    room: r,
                                                    x: startX,
                                                    y: startY
                                                    },
                                            end: {
                                                    room: foundRoomIndex,
                                                    x: next.x,
                                                    y: next.y
                                                },
                                            dir: dir,
                                            distance: distance
                                            });

                            if (adjacencyList[r] === null || adjacencyList[r] === undefined) {
                                adjacencyList[r] = [];
                            }
                            // uncomment the next line if we want an equal chance of corridor for
                            // neighbors with only 1 possible connection vs many possible connections
                            //if (adjacencyList[r].indexOf(foundRoomIndex) === -1) {
                                adjacencyList[r].push(foundRoomIndex);
                            //}

                        } else {    // we didn't find a room
                            // keep searching (continue with the do/while loop)
                            current = next;
                            distance++;
                        }

                    } else {    // getNextCorridorTile() returned the same tile; we can't continue in dir.
                        break;  // break out of while loop and continue with walls loop.
                    }
                } while (!endRoomFound);
            }
        }
    }

    this.roomsGraph = roomsGraph;

    return adjacencyList;
};

Game.Dungeon.BSP.prototype.placeCorridors = function(graph, start, extraCorridorChance) {
    // essentially, this is a BFS (breadth-first search) graph traversal algorithm.
    // graph should be a hashtable adjacencyList: {roomIndex: [neighborsArray] }
    // start should be a number corresponding to a roomIndex in this.rooms
    extraCorridorChance = extraCorridorChance || 5;

    if (this.corridors === null || this.corridors === undefined) {
        this.corridors = [];
    }

    var connectedRooms = {};       // stored as {roomIndex, [list of connected rooms]

    var seen = new Array(this.rooms.length);    // stores whether we have visited this roomIndex
    var q = [];                                 // roomIndexes with neighbors to investigate
    q.push(start);
    seen[start] = true;
    while (q.length !== 0) {

        q = q.randomize();

        var i = q.shift();              // get the first roomIndex in the queue
        var nbors = graph[i].randomize();     // get the neighborsArray for this roomIndex

        // "explore" (add to queue) the neighbors
        for (var j = 0; j < nbors.length; j++) {
            var n = nbors[j];           // n is a roomIndex of a neighbor of i
            if (!seen[n]) {             // if we haven't been here before
                q.push(n);              // add this roomIndex to the queue
                seen[n] = true;         // and mark it seen.

                // make a corridor between n and i
                this.makeCorridor(i, n);
                if (connectedRooms[n] === null || connectedRooms[n] === undefined) {
                    connectedRooms[n] = [];
                }
                connectedRooms[n].push(i);
                if (connectedRooms[i] === null || connectedRooms[i] === undefined) {
                    connectedRooms[i] = [];
                }
                connectedRooms[i].push(n);     // so it goes both ways

                // if we HAVE been here before, chance for extra corridor if one doesn't
                // exist between these rooms already
            } else if (ROT.RNG.getPercentage() < extraCorridorChance &&
                       connectedRooms[n].indexOf(i) === -1 &&
                       connectedRooms[i].indexOf(n) === -1) {
                this.makeCorridor(i, n);
                connectedRooms[n].push(i);
                connectedRooms[i].push(n);     // so it goes both ways
            }
        }
    }
    return connectedRooms;
};

Game.Dungeon.BSP.prototype.makeCorridor = function(startRoomIndex, endRoomIndex) {
    // when this is called, we should already have a this.roomsGraph array
    // of connections: {start: {room, x,y}, end: {room, x,y}, dir, distance}.
    // This lists all possible connections between rooms.

    // loop through roomsGraph array looking for roomsGraph[i].start.room = startRoomIndex,
    // with the corresponding endRoomIndex.
    // there will usually be several entries, one for each possible (x,y) connection.
    // store all possibilities for startRoom => endRoom.
    var connections = [];

    for (var i = 0; i < this.roomsGraph.length; i++) {
        if (this.roomsGraph[i].start.room === startRoomIndex &&
            this.roomsGraph[i].end.room === endRoomIndex) {

                connections.push(this.roomsGraph[i]);
        }
    }

    // Now, let's pick a random connection to try.
    connections = connections.randomize();
    var conn = connections.random();

    // start at start (x,y), dig in dir for distance, until end (x,y) is reached.
    // distance is how many tiles we need to dig.

    // actually, we can get both distance and direction from end(x,y) - start(x,y),
    // since for start(x,y) and end(x,y), either one of x or y should stay constant.

    var dX = conn.end.x - conn.start.x;     // (+) dig east, (-) dig west
    var dY = conn.end.y - conn.start.y;     // (+) dig south, (-) dig north

    var distance = Math.max(Math.abs(dX), Math.abs(dY));

    for (var d = 0; d < distance; d++) {

        // get new coords based on start, distance, and direction.
        // if dX is (+), add d; else, if dX is (-), subtract d.
        var cX = conn.start.x + (dX > 0 ? d : (dX < 0 ? (-d) : 0) );
        var cY = conn.start.y + (dY > 0 ? d : (dY < 0 ? (-d) : 0) );

        this.corridors.push({x: cX, y: cY});
    }
};


Game.Dungeon.BSP.prototype.isWithinRoom = function(x, y) {
    /*
        loop through rooms array comparing x, y.
        if found, return room array index; if not found, return -1.
     */
    var foundIndex = -1;

    for (var p = 0; p < this.rooms.length; p++) {
        for (var pY = this.rooms[p].topLeftY; pY <= this.rooms[p].bottomRightY; pY++) {
            for (var pX = this.rooms[p].topLeftX; pX <= this.rooms[p].bottomRightX; pX++) {
                if (pX === x && pY === y) {
                    foundIndex = p;
                    break;
                }
            }
        }
    }
    return foundIndex;
};

Game.Dungeon.BSP.prototype.getNextCorridorTile = function(currentCorridorTile) {
    /*
        Take the currentCorridorTile {x, y, dir} and try to continue
        the corridor with nextCorridorTile in the same dir.
     */

    var mapWidth = this.masterWidth;
    var mapHeight = this.masterHeight;
    var inBounds = false;

    var nextCorridorTile = { x: currentCorridorTile.x, y: currentCorridorTile.y, dir: currentCorridorTile.dir };

    // switch perimeter.dir:
    if (currentCorridorTile.dir === 0 && currentCorridorTile.y > 0) {            // north
        // X will stay the same; make sure next Y is within bounds.
        nextCorridorTile.y = currentCorridorTile.y - 1;
        inBounds = true;
    } else if (currentCorridorTile.dir === 1 && currentCorridorTile.x < mapWidth - 1) {     // east
        // Y will stay the same; make sure next X is within bounds.
        nextCorridorTile.x = currentCorridorTile.x + 1;
        inBounds = true;
    } else if (currentCorridorTile.dir === 2 && currentCorridorTile.y < mapHeight - 1) {     // south
        // X will stay the same; make sure next Y is within bounds.
        nextCorridorTile.y = currentCorridorTile.y + 1;
        inBounds = true;
    } else if (currentCorridorTile.dir === 3 && currentCorridorTile.x > 0) {     // west
        // Y will stay the same; make sure next X is within bounds.
        nextCorridorTile.x = currentCorridorTile.x - 1;
        inBounds = true;
    }

    if (inBounds) {
        return nextCorridorTile;
    } else {
        return currentCorridorTile;
    }

};

Game.Dungeon.BSP.prototype.getPerimeters = function(room, dir) {
/*
     get the perimeter walls of each room.
     (tile position and heading)

     for each room: {topLeftX, topLeftY, bottomRightX, bottomRightY},
     the perimeter tiles will be defined by:

     north heading:  (leftmost X, topmost Y - 1) to (rightmost X, topmost Y - 1)
     south heading:  (leftmost X, bottommost Y + 1) to (rightmost X, bottommost Y + 1)
     west heading:   (leftmost X - 1, topmost Y) to (leftmost X - 1, bottommost Y)
     east heading:   (rightmost X + 1, topmost Y) to (rightmost X + 1, bottommost Y)

     north:  {topLeftX, topLeftY - 1, bottomRightX, topLeftY - 1}
     south:  {topLeftX, bottomRightY + 1, bottomRightX, bottomRightY + 1}
     west:   {topLeftX - 1, topLeftY, topLeftX - 1, bottomRightY}
     east:   {bottomRightX + 1, topLeftY, bottomRightX + 1, bottomRightY}

     before storing, we should check to see if it's out of bounds.
*/

    var mapWidth = this.masterWidth;
    var mapHeight = this.masterHeight;

    var checkAll = false;
    if (dir === undefined || dir === null) {
        checkAll = true;
    }

    // store the perimeter tiles for each direction
    var perimeters = [];        // array of objects: {x, y, dir}

    var pX, pY;
    // north heading: Y doesn't change; loop through X
    // make sure Y is within bounds before starting.
    if (room.topLeftY > 0 && (dir === 0 || checkAll)) {
        for (pX = room.topLeftX; pX <= room.bottomRightX; pX++) {
            // make sure X is within bounds before storing.
            if (pX >= 0 && pX < mapWidth) {
                perimeters.push({ x: pX, y: room.topLeftY - 1, dir: 0 });
            }
        }
    }
    // east heading: X doesn't change; loop through Y
    // make sure X is within bounds before starting.
    if (room.bottomRightX < mapWidth - 1 && (dir === 1 || checkAll)) {
        for (pY = room.topLeftY; pY <= room.bottomRightY; pY++) {
            // make sure Y is within bounds before storing.
            if (pY >= 0 && pY < mapHeight) {
                perimeters.push({ x: room.bottomRightX + 1, y: pY, dir: 1 });
            }
        }
    }
    // south heading: Y doesn't change; loop through X
    // make sure Y is within bounds before starting.
    if (room.bottomRightY < mapHeight - 1 && (dir === 2 || checkAll)) {
        for (pX = room.topLeftX; pX <= room.bottomRightX; pX++) {
            // make sure X is within bounds before storing.
            if (pX >= 0 && pX < mapWidth) {
                perimeters.push({ x: pX, y: room.bottomRightY + 1, dir: 2 });
            }
        }
    }
    // west heading: X doesn't change; loop through Y
    // make sure X is within bounds before starting.
    if (room.topLeftX > 0 && (dir === 3 || checkAll)) {
        for (pY = room.topLeftY; pY <= room.bottomRightY; pY++) {
            // make sure Y is within bounds before storing.
            if (pY >= 0 && pY < mapHeight) {
                perimeters.push({ x: room.topLeftX - 1, y: pY, dir: 3 });
            }
        }
    }

    return perimeters;
};

/*
    "Feature Based" Dungeon Building Algorithm (originally by Mike Anderson)
    from http://www.roguebasin.com/index.php?title=Dungeon-Building_Algorithm

    code ported from C++ implementation (version 2 by netherh)
    http://www.roguebasin.com/index.php?title=C%2B%2B_Example_of_Dungeon-Building_Algorithm
 */

Game.Dungeon.FeatureBased = function(map, tileset, options) {
    options = options || {};
    this.mapWidth = options['width'] || 100;
    this.mapHeight = options['height'] || 100;

    if (!map) {
        var grid = new Array(this.mapWidth);
        for (var i = 0; i < this.mapWidth; i++) {
            grid[i] = new Array(this.mapHeight);
        }
    }

    if (!tileset) {
        tileset = Game.Tilesets.cave;
    }

    this.map = map || new Game.Map(grid, tileset);
    this.tileset = tileset;

    this.maxFeatures = options['maxFeatures'] || 100;
    this.roomChance = options['roomChance'] || 75;      // lower = more corridors
    this.corridorChance = options['corridorChance'] || (100 - this.roomChance);

    this.maxRoomSize = options['maxRoomSize'] || 10;
    this.maxRoomWidth = options['maxRoomWidth'] || this.maxRoomSize;
    this.maxRoomHeight = options['maxRoomHeight'] || this.maxRoomSize;
    this.maxCorridorLength = options['maxCorridorLength'] || 6;
};

Game.Dungeon.FeatureBased.prototype.generate = function() {
    // make one room in the center of map to start off
    this.makeRoom(this.mapWidth / 2, this.mapHeight / 2,
                  this.maxRoomWidth, this.maxRoomHeight, randomInt(0, 3));

    for (var f = 1; f < this.maxFeatures; f++) {

        if (!this.tryExpansion()) {
            console.log('Unable to place more features (placed ' + f + ').');
            break;
        }
    }

    if (!this.makeStairs(this.tileset.stairsUp)) {
        console.log('Unable to place stairs up.');
    }

    if (!this.makeStairs(this.tileset.stairsDown)) {
        console.log('Unable to place stairs down.')
    }

    return true;
};

Game.Dungeon.FeatureBased.prototype.makeCorridor = function(x, y, maxLength, dir) {
    // sanity checks
    if (!this.map.checkX(x) || !this.map.checkY(y)) {
        return false;
    }
    if (maxLength <= 0 || maxLength > Math.max(this.mapWidth, this.mapHeight)) {
        return false;
    }

    var length = randomInt(2, maxLength);
    var xStart = x;
    var yStart = y;
    var xEnd = x;
    var yEnd = y;

    if (dir === 0 || dir === 'N' || dir === 'n') {
        yStart = y - length;
    } else if (dir === 1 || dir === 'E' || dir === 'e') {
        xEnd = x + length;
    } else if (dir === 2 || dir === 'S' || dir === 's') {
        yEnd = y + length;
    } else if (dir === 3 || dir === 'W' || dir === 'w') {
        xStart = x - length;
    }

    if (!this.map.checkX(xStart) || !this.map.checkX(xEnd) ||
        !this.map.checkY(yStart) || !this.map.checkY(yEnd)) {
        return false;
    }

    if (!this.map.isAreaTiled(xStart, yStart, xEnd, yEnd, Game.Tile.nullTile)) {
        return false;
    }

    this.map.tileArea(xStart, yStart, xEnd, yEnd, this.tileset.corridor);
    return true;
};

Game.Dungeon.FeatureBased.prototype.makeRoom = function(x, y, xMax, yMax, dir) {
    // minimum room size of 5x5 tiles (3x3 for walking on, the rest is walls)
    var xLength = randomInt(5, xMax);
    var yLength = randomInt(5, yMax);

    var xStart = x;
    var yStart = y;

    var xEnd = x;
    var yEnd = y;

    if (dir === 0 || dir === 'N' || dir === 'n') {
        yStart = y - yLength;
        xStart = x - xLength / 2;
        xEnd = x + (xLength + 1) / 2;
    } else if (dir === 1 || dir === 'E' || dir === 'e') {
        yStart = y - yLength / 2;
        yEnd = y + (yLength + 1) / 2;
        xEnd = x + xLength;
    } else if (dir === 2 || dir === 'S' || dir === 's') {
        yEnd = y + yLength;
        xStart = x - xLength / 2;
        xEnd = x + (xLength + 1) / 2;
    } else if (dir === 3 || dir === 'W' || dir === 'w') {
        yStart = y - yLength / 2;
        yEnd = y + (yLength + 1) / 2;
        xStart = x - xLength;
    }

    if (!this.map.checkX(xStart) || !this.map.checkX(xEnd) ||
        !this.map.checkY(yStart) || !this.map.checkY(yEnd)) {
        return false;
    }

    if (!this.map.isAreaTiled(xStart, yStart, xEnd, yEnd, Game.Tile.nullTile)) {
        return false;
    }

    this.map.tileArea(xStart, yStart, xEnd, yEnd, this.tileset.wall);
    this.map.tileArea(xStart + 1, yStart + 1, xEnd - 1, yEnd - 1, this.tileset.floor);
    return true;
};

Game.Dungeon.FeatureBased.prototype.makeFeature = function(x, y, xmod, ymod, dir) {
    // choose what to build
    var chance = randomPercent();

    // TODO: this could be extended to pull other features from a chance table

    if (chance < this.roomChance) {
        if (this.makeRoom(x + xmod, y + ymod, this.maxRoomWidth, this.maxRoomHeight, dir)) {

            this.map.grid[x][y] = this.tileset.closedDoor;
            // remove wall adjacent to the door
            this.map.grid[x + xmod][y + ymod] = this.tileset.floor;

            return true;
        }
        return false;

    } else {
        if (this.makeCorridor(x + xmod, y + ymod, this.maxCorridorLength, dir)) {

            this.map.grid[x][y] = this.tileset.closedDoor;
            return true;
        }
        return false;
    }

};

Game.Dungeon.FeatureBased.prototype.tryExpansion = function() {

    var map = this.map;
    var maxTries = 1000;

    var x, y;
    for (var tries = 0; tries < maxTries; tries++) {
        // Pick a random wall or corridor tile.
        // Make sure it has no adjacent doors (looks weird to have doors next to each other)
        // Find a direction from which it's reachable.
        // Attempt to make a feature (room or corridor) starting at this point.

        x = randomInt(1, this.mapWidth - 2);
        y = randomInt(1, this.mapHeight - 2);

        if (map.getTile(x, y) !== this.tileset.wall &&
            map.getTile(x, y) !== this.tileset.corridor) {
            continue;
        }

        if (map.isAdjacent(x, y, this.tileset.closedDoor)) {
            continue;
        }

        if (map.getTile(x, y + 1) === this.tileset.floor ||
            map.getTile(x, y + 1) === this.tileset.corridor) {
            if (this.makeFeature(x, y, 0, -1, 'N')) {
                    return true;
                }
        } else if (map.getTile(x - 1, y) === this.tileset.floor ||
                   map.getTile(x - 1, y) === this.tileset.corridor) {
            if (this.makeFeature(x, y, 1, 0, 'E')) {
                return true;
            }
        } else if (map.getTile(x, y - 1) === this.tileset.floor ||
                   map.getTile(x, y - 1) === this.tileset.corridor) {
            if (this.makeFeature(x, y, 0, 1, 'S')) {
                return true;
            }
        } else if (map.getTile(x + 1, y) === this.tileset.floor ||
                   map.getTile(x + 1, y) === this.tileset.corridor) {
            if (this.makeFeature(x, y, -1, 0, 'W')) {
                return true;
            }
        }
    }
    return false;
};

Game.Dungeon.FeatureBased.prototype.makeStairs = function(tile) {

    var map = this.map;
    var maxTries = 10000;

    var x, y;
    for (var tries = 0; tries < maxTries; tries++) {

        x = randomInt(1, this.mapWidth - 2);
        y = randomInt(1, this.mapHeight - 2);

        if (!map.isAdjacent(x, y, this.tileset.floor) &&
            !map.isAdjacent(x, y, this.tileset.corridor)) {
            continue;
        }

        if (map.isAdjacent(x, y, this.tileset.closedDoor)) {
            continue;
        }

        map.grid[x][y] = tile;
        return true;
    }
    return false;
};


